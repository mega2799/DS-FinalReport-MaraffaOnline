\chapter{Architettura e Design}
\label{ch:architectures}

\section{Design generale del software}

L'architettura del software è basata su micro-servizi autonomi e indipendenti tra loro e la loro comunicazione avviene tramite API REST.
Esiste un middleware che si occupa della gestione e dell'orchestrazione dei micro-servizi, facendo appunto da ponte collegando le varie diverse tencologie.

I microservizi che si sono scelti di sviluppare si occupano di varie aree legate alla natura del progetto e sono:
\begin{itemize}
    % \item \textbf{ChatService}: si occupa della gestione delle chat tra utenti.
    \item \textbf{UserService}: si occupa della gestione degli utenti, quindi la loro registrazione, autenticazione e gestione dei dati personali.
    \item \textbf{BusinessLogic}: si occupa di mantenere al proprio interno tutte le regole proprie del gioco
    \item \textbf{Front-End}: si occupa di gestire l'interfaccia grafica e la comunicazione con il middleware.
    \item \textbf{Middleware}: si occupa della gestione delle comunicazioni tra i vari microservizi, e svolge la funzione di "motore di gioco".
\end{itemize}

\includegraphics[width=12cm]{report/img/Architecture.png}\\[10.5cm]

\section{Micro-servizi e la loro architettura}

% \subsection{Servizio per la Chat}

% \begin{table}[h!]
%     \centering
%     \caption{Tabella descrittiva Chat Service}
%     \label{tab:chat_serv_table}
%     \begin{tabular}{ll}     
%         \toprule                   
%         Linguaggio & Java \\        
%         Server & Vertx, Swagger \\
%         Librerie & RabbitMQ(vertx) \\
%         Architettura & Agenti vertx \\
%         \bottomrule
%     \end{tabular}
% \end{table}

% \includegraphics[width=15cm]{report/img/Architettura ChatService.png}\\[10.5cm]

\subsection{Servizio per Gestione Utenti}

\begin{table}[h!]
    \centering
    \caption{Tabella descrittiva User Service}
    \label{tab:user_serv_table}
    \begin{tabular}{ll}     
        \toprule                   
        Linguaggio & Node.JS/TypeScript \\        
        Framework & NestJS   \\                   
        Persistence & Mysql  \\
        Librerie & TypeORM   \\
        Architettura & Model-Controller-service  \\
        \bottomrule
    \end{tabular}
\end{table}


\subsection{Servizio Business Logic}

\begin{table}[h!]
    \centering
    \caption{Tabella descrittiva Business Logic}
    \label{tab:bl_serv_table}
    \begin{tabular}{ll}     
        \toprule                   
        Linguaggio & Node.JS/TypeScript \\        
        Framework & NestJS   \\                   
        Architettura & Model-Controller-service  \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Servizio ponte tra i microservizi}


\begin{table}[h!]
    \centering
    \caption{Tabella descrittiva Middleware}
    \label{tab:middleware_serv_table}
    \begin{tabular}{ll}     
        \toprule                   
        Linguaggio & Java \\        
        Server & Vertx \\
        Librerie & RabbitMQ(vertx) \\
        Architettura & Multi-agent, motore di gioco \\
        \bottomrule
    \end{tabular}
\end{table}

\section{[DS/SPE] Perche' i microservizi?}

Ogni microservizio si occupa di gestire un singolo ambito di progetto, il che fa sì che si ottengano ottimi risultati riguardo la qualità e l'affidabilità, la riutilizzabilità, la flessibilità e la scalabilità.
Tutti i componenti sono "loosely coupled", distribuiti in modo indipendente, altamente collaudabili e gestibili e in ambiti reali gestiti da un piccolo team.
Tuttavia, non si tratta di una soluzione definitiva, ha anche degli svantaggi come ad esempio:
\begin{itemize}
    \item la complessità di gestione e la necessità di un'infrastruttura di rete molto complessa.
    \item un'ottima comunicazione di team.
    \item una discreta capacità di astrazione e progettazione di interfaccie di comunicazione che devono essere rispettate da tutti i microservizi.
    \item Non si ha la certezza che l'infrastruttura funzioni correttamente fino a quando tutti i servizi non cooperano tra loro.
\end{itemize}

% \subsection{[SPE] Vantaggi}
% - devops
% - ci 

\subsection{Vantaggi architettura a microservizi}

\subsubsection{Fault Tolerance}

Progettare un sistema completamente privo di errori è una obbiettivo decisamente ambizioso e molto difficile da raggiungere. 
Molto più realistico, e inerente al nostro percorso, è progettare un sistema che sia in grado di tollerare, nella giusta misura, gli errori che inevitabilmente si verificheranno. 
La scelta di questa architettura tra i vari vantaggi offre la possibilità di \textbf{isolare parti del sistema} evitando che gli errori si propaghino in modo incontrollato e che il sistema nel suo complesso vada in crash. 
Ogni sistema opera in modo indipendente e autonomo, con le proprie risorse e la propria logica.

Lo snodo centrale di comunicazione dei servizi, il middleware, è in grado di gestire le comunicazioni tra i vari microservizi e di garantire che il sistema sia in grado di funzionare anche in caso di guasti.
Purtoppo non esiste alcun progetto senza alcun tipo di \textbf{single point of failure} o almeno non con le risorse a disposione di noi studenti, quindi all'interno di questo servizio la 
gestione degli errori dei servizi con cui comunica è gestita ma di fatto nel caso in cui il middleware smetta di funzionare allora non avendo nessuno altro servizio che possa fare da garante 
per il suo corretto funzionamento tutto il sistema non permettarà ad esempio di giocare a nessun gioco.
Questo in quanto il middleware è il cuore pulsante del sistema, avendo disponibiltà di risorse e abbastanza conoscenze in un ambito reale questo problema ha soluzioni: 
\begin{itemize}
    \item \textbf{Backup del middleware}: avere dei backup dei processi che si occupano di gestire le partite, ma questo significherebbe andare a modificare inevitabilmente 
    la struttura già esistente del servizio.
    \item \textbf{Ridondanza del middleware}: avere molteplici instanze del middleware, preferibilmente 3, di cui una principale e le altre 2 in copia, facendo in modo che
    ogni azione sul middleware principale venga replicata sulle altre due istanze e che quinndi in caso di guasto hardware le altre copie possano rispondere alle richieste.
\end{itemize}

\subsubsection{Scalability}

Nel caso del middleware la scalabilità è un altro modo per chiamare la duplicazione, ma questo si applica soltanto al middleware, in quanto i microservizi sono realmente scalabili.
Ogni microservizio è in grado di scalare in modo indipendente, in base alle proprie esigenze, e questo permette di avere un sistema che si adatta in modo dinamico alle richieste degli utenti. 
Nella prossima sezione verrà approfondito come il deployment con docker che permette di scalare i microservizi. L'implementazione di un sistema di load balancing viene fornita
"gratuitamente" da Kubernetes, che permette di bilanciare il carico tra i vari nodi del cluster. 
Qualora il progetto maraffa-online dovesse avere un numero di utenti molto elevato, si potrebbe pensare di scalare il sistema in modo orizzontale, aggiungendo nuovi nodi al cluster, 
e tramite la dovuta configurazione, Kubernetes si occuperebbe di bilanciare il carico tra i vari nodi dei servizi scalabili. 

\subsubsection{Docker}
% - fault tolerance
% - scalability
% - docker